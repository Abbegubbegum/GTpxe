#!/bin/ash
#shellcheck shell=dash
# /etc/local.d/run_diagnostic.start

set -u

print_green() {
    printf '\033[0;32m%s\033[0m\n' "$1"
}

# same for red
print_red() {
    printf '\033[0;31m%s\033[0m\n' "$1"
}

# This block is for creating a watcher that reads if "q" is pressed to quit the tests early without waiting for input.

start_abort_watcher() {
    (
        exec < "/dev/tty1" > /dev/null 2>&1
        
        OLDSTTY=$(stty -g)
        stty -echo -icanon min 0 time 0
        
        while :; do
            char=$(dd bs=1 count=1)
            if [ "$char" = "q" ]; then
                print_red "[ABORT] Key press received. Exiting tests." > /dev/tty1
                kill -KILL "$$"
                break
            fi
            sleep 0.1
        done
        
        stty "$OLDSTTY"
    ) & ABORT_WATCHER_PID=$!
}

cleanup_abort_watcher() {
    [ -n "$ABORT_WATCHER_PID" ] && kill "$ABORT_WATCHER_PID"
}

start_abort_watcher

run_in_vt() {
    # which VT are we currently on? (e.g. "tty1")
    orig=$(cat /sys/class/tty/tty0/active)   # outputs "ttyN"
    orig=${orig#tty}
    
    # run TUI on a different VT (let openvt pick a free one)
    # -s: switch to it, -w: wait for it to exit, -f: force if busy
    openvt -swf -- "$1"
    
    # return to where we started
    chvt "$orig"
    
    # (optional) if the keyboard feels weird back on tty$orig:
    stty sane </dev/tty"$orig" || true
    
}

# This function is used to run the keyboard test in a separate VT.
run_input_device_test() {
    run_in_vt /home/ssh/binaries/input_device_test
}

run_screen_test() {
    run_in_vt /home/ssh/binaries/screen_test
}

ask_continue() {
    printf '\033[0;33m%s\033[0m' "Do you want to continue with the remaining tests? (y/N): "
    read -r answer < /dev/tty1
    case "$answer" in
        [Yy]*)
            print_green "Continuing tests..."
            return 0
        ;;
        *)
            print_red "Exiting tests."
            return 1
        ;;
    esac
}

exit_program() {
    cleanup_abort_watcher
    cleanup_log_file
    exit 1
}

cleanup_log_file() {
    # --- Clean up the log file (remove color codes) ---
    # Remove ANSI escape sequences like ^[[0;31m, etc.
    sed -i 's/\x1B\[[0-9;]*[A-Za-z]//g' /root/diagnostic_report.txt
    
    # Remove all of the progress indications from memtester and only keep ok
    sed -i 's/: .*ok$/: ok/' /root/diagnostic_report.txt
}

# Redirect stdout and stderr to /dev/tty1 for visibility, and tee to a text output
# Its needed because the script is run in a non-interactive environment so stdout is not set yet.

# Create a temporary FIFO for tee
tmpf=/tmp/diag_fifo
mkfifo "$tmpf"
tee /root/diagnostic_report.txt <"$tmpf" >/dev/tty1 &
exec >"$tmpf" 2>&1
rm "$tmpf"

# This script runs the diagnostic tests for the client application.
print_green "Running diagnostic tests..."
print_green "Press 'q' to abort the tests early."

# Wait for early exit
sleep 2

printf "\n"
# Get core count
CORE_COUNT=$(nproc)

print_green "Starting Memory/CPU Test with stress-ng"

if ! stress-ng --cpu "$CORE_COUNT" --vm "$CORE_COUNT" --vm-bytes 75% --timeout 30s --metrics-brief
then
    print_red "Memory/CPU Test failed."
    if ! ask_continue; then
        exit_program
    fi
else
    print_green "Memory/CPU Test completed successfully."
fi

print_green "Running Memtest for memory testing..."

if ! memtester 100M 1
then
    print_red "Memtest failed."
    if ! ask_continue; then
        exit_program
    fi
else
    print_green "Memtest completed successfully."
fi

print_green "Running Disk Selftest..."
if ! python -u /home/ssh/python/disk_health.py
then
    print_red "Disk check failed."
    if ! ask_continue; then
        exit_program
    fi
else
    print_green "Disk selftest completed successfully"
fi

print_green "Running USB test..."
if ! python -u /home/ssh/python/usb_test.py
then
    print_red "USB test failed."
    if ! ask_continue; then
        exit_program
    fi
else
    print_green "USB test completed successfully"
fi

print_green "ACPI Status:"
acpi -V

print_green "Test Serial Ports..."

if ! /home/ssh/scripts/serial_test.sh
then
    print_red "Serial test possible failure."
    # Don't exit here because there are serial port chips that are not connected to anything.
    # It fails but its expected.
else
    print_green "Serial test completed successfully."
fi

#Kill the watcher before starting the interactive tests
cleanup_abort_watcher

# Check if there are any sound cards available
if [ -d /proc/asound ] && [ -n "$(ls -A /proc/asound/card* 2>/dev/null)" ]; then
    # Set volume on soundcard
    amixer -c 0 sset Master 100% unmute >/dev/null 2>&1 || true
    amixer -c 0 sset PCM 100% unmute >/dev/null 2>&1 || true
    
    # Basic tone
    speaker-test -t sine -f 880 -l 1 >/dev/null 2>&1
else
    print_red "No sound cards found - skipping speaker test."
fi

print_green "Running GPS Test..."

# Function to check if a device outputs NMEA sentences (GPS data)
is_gps_device() {
    device=$1
    # Read from device for 2 seconds and check for NMEA sentences
    # NMEA sentences start with $ and contain common GPS headers like GPGGA, GPRMC, etc.
    timeout 2 cat "$device" 2>/dev/null | grep -q '^\$G[NP]' && return 0
    return 1
}

# Look for GPS on ttyACM devices
gps_device=""
for tty in /dev/ttyACM*; do
    [ -e "$tty" ] || continue
    if is_gps_device "$tty"; then
        gps_device="$tty"
        break
    fi
done

# If GPS found, run the test
if [ -n "$gps_device" ]; then
    print_green "Found GPS at $gps_device"
    # Start gpsd daemon
    if gpsd "$gps_device" -n -F /var/run/gpsd.sock; then
        sleep 2
        # Verify gpsd is actually receiving GPS data
        if gpspipe -w -n 5 2>/dev/null | grep -q "TPV\|SKY"; then
            # Run gpsmon in a separate VT to avoid disrupting output
            run_in_vt cgps
            print_green "GPS test completed."
        else
            print_red "GPS device found but not responding - skipping GPS test."
            killall gpsd 2>/dev/null || true
        fi
    else
        print_red "Failed to start gpsd - skipping GPS test."
    fi
else
    print_red "No GPS device found - skipping GPS test."
fi

run_input_device_test

run_screen_test

# Play the beep at the start to indicate the end of tests
# But play this at the end so we know the user will hear it
if [ -d /proc/asound ] && [ -n "$(ls -A /proc/asound/card* 2>/dev/null)" ]; then
    # Simple talking
    aplay /usr/share/sounds/alsa/Front_Center.wav >/dev/null 2>&1
fi

print_green "All tests completed. GTUA"

cleanup_log_file
exit 0
